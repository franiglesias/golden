# Golden

A Go library for snapshot ðŸ“¸ testing.

## TL;DR

Snapshot testing is a testing technique in which the output of the subject under test is compared to a previous output (the snapshot) generated by running the same subject under test.

This is useful to:

* understand legacy code
* obtain high code coverage when starting to refactor legacy
* test complex outputs (objects, files, etc)

> Current Status: verify and approval mode. Test name customization. 

### Installation

No, seriously. It's not ready âœ‹.

But you could experiment with the basic snapshot verification facility and approval. 

At this point there are no utilities for customizing any aspect of golden functionality.

```shell
go get -u github.com/franiglesias/golden
```

### Basic Usage

A snapshot test is pretty easy to write. Capture the output of the subject under test and pass it to `golden.Verify`. That's all.

```go
func TestSomething(t *testing.T) {
	output := SomeFunction("param1", "param2")
	
	golden.Verify(t, output)
}
```

The first time you run the test, a snapshot file will be generated at `__snapshots/TestSomething.snap` in the same package of the test.

The file will contain the output generated by the subject under test, provided that it can be serialized as JSON. You can inspect the snapshot to check that it contains the output you expect.

If you consider that the snapshot is not correct, simply delete it.

If the snapshot is ok for you, commit it with the code, so it can be used as comparison criteria for future runs.

#### Customize the snapshot name

You can customize the snapshot name:

```go
func TestSomething(t *testing.T) {
	output := SomeFunction("param1", "param2")
	
	golden.UseSnapshot("my_snapshot").Verify(t, output)
}
```

This will generate a snapshot in `__snapshots/my_snapshot.snap` in the same package of the test.

This is useful is you need:

* Use more than one snapshot in the same test
* Use an externally generated file as snapshot. For example, if you want your code to replicate the output of another system, provided that you have an example.

## What is Golden?

Golden is a library inspired by projects like [Approval Testing](https://approvaltests.com/). There are some other similar libraries out there, such as [Approval Tests](https://github.com/approvals/go-approval-tests), [Go-snaps](https://github.com/gkampitakis/go-snaps) or [Cupaloy](https://github.com/bradleyjkemp/cupaloy).

So... Why to reinvent the wheel?

First of all, why not? I was willing to start a little side project to learn and practice some Golang things that I didn't find opportunity during the daily work. For example, creating a library for distribution, some questions about managing state, creating fluent APIs, managing unknown types, etc. 

Second. I found some limitations in the libraries I was using (Approval tests, mainly) that make the work a bit uncomfortable. So, I started to look for alternatives. I wanted some more flexibility and customization.  

## Snapshot testing

Snapshot testing is a testing technique that provides an alternative to assertion testing. In assertion testing, you compare the output of executing some unit of code with some expectation you have about it. For example, you could expect that the output would equal some value, or that it contains some text, etc.

```go
assert.Equal(t, "Expected", output)
```

This works very well for TDD and testing simple outputs. But it is tedious if you need to test complex objects, generated files and other big outputs. Also, it is not a good tool for testing code that you don't know well or that was not created with testing in mind.

In snapshot testing, instead, you first obtain and persist the output of the execution. This is what we call a snapshot.

Then, you make some changes in the affected code, execute the unit again and, finally, you compare this output with the one you persisted. As you can guess, in order to make the test pass, the code changes should not affect the behavior. This way, it is easy to understand that snapshot testing is great to put existing working code under test.

Golden automates the process of creating the snapshot the first time that the test runs and use it as criteria in the following ones.

```go
golden.Verify(t, output)
```

But testing legacy or unknown code is not the only use case for snapshot testing.

In fact, snapshot testing is perfect for testing complex objects or outputs, such as html, xml, json, generated code, etc. Provided that you can create a file with a serialized representation of the response, you can compare the snapshot with subsequent executions of the same unit of code. I mean: suppose you need to generate an API response with lots of data. Instead of trying to figure out how to check every field value, you generate a snapshot with the expected data. After that, you will be using that snapshot to verify the execution. 

But this way of testing is weird for developing new features... How can I know that my generated output is correct so far?

## Approval testing

Approval testing is a variation of snapshot testing. Usually, in snapshot testing, the first time you execute the test, a new snapshot is created and the test automatically passes. Then, you make changes to the code and use the snapshot to ensure there are not behavioral changes. By the way, this is the default behavior of `Golden`.

In Approval Testing, the first test execution is not automatically passed. Instead, the snapshot is created, but you should review and approve it explicitly. This step allows you to be sure that the output is what you want it to be. You can show it to the business people, to your client, to the user of your API or to whoever can review it. Once you get the approval of the snapshot and re-run the test, it will pass.

In fact, you could make changes and re-run the test until you are satisfied with the output and get the approval.

I think that Approval Testing was first introduced by [Llewellyn Falco](https://twitter.com/llewellynfalco). You can [learn more about this technique in their website](https://approvaltests.com/), where you can find how to approach development with it.

### How to do approval testing with Golden

Imagine you are writing some code that generates a complex Json object or another long and complex document. You need this object to be reviewed by a domain expert to ensure that it contains what the code is supposed to generate.

If you work in "verification mode" you will have to delete every snapshot that is created when running the test. Instead of that, you can use the "approval mode". It is very easy: you simply have to use the "ToApprove" function until the snapshot reflects exactly what you or the domain expert want.

```go
func TestSomething(t *testing.T) {
    output := SomeFunction("param1", "param2")

    golden.ToApprove(t, output)
}
```

This way, the test will always fail, and it will update the snapshot with the changes that happen in the output. This is because in "approval mode" you don't want to allow the test pass.

So, how I can mark that a snapshot was approved? Easy: simple change the test to use the verification mode once you confirmed that the last snapshot was approved:

```go
func TestSomething(t *testing.T) {
    output := SomeFunction("param1", "param2")

    golden.Verify(t, output)
}
```

Other libraries requires you to use some sort external tool to rename or mark a snapshot as approved. Golden puts this distinction into the test itself. The fact that it fails, allows you to remember that you will need to make something with the test. 

## Golden master

There is another variation of snapshot testing. **Golden Master** is a technique introduced by Michael Feathers for working with legacy code that you don't understand. With this technique you could achieve 100% coverage really fast, so you can be sure that refactoring will be safe because you always will know if behaviour of the code is broken due to a change you introduced. And the best thing is that you don't need to really understand the code. Once you start refactoring thins, it will be easier to introduce classic assertion testing and probably remove the Golden Master tests.

It consists in the creation of a lot of tests for the same unit of code, introducing combinations of the parameters that you need to pass to such unit. The original Approval Tests library includes Combinations, a library that helps you to generate those combinatorial tests. There are several techniques to guess the best values you can use. You can study the code and search for values in conditionals, for example, with the help of a graphical coverage tool that shows you what parts of the code are executed or not depending on the values.

Once you complete the collection of possible values for each parameter, you will use the combination tools and a lot of tests will be generated for you. The amount of tests is the product of multiplying the number of values per parameter. You can easily achieve tenths and even hundreds of tests for the same code unit.

As you have probably guessed, Golden takes its name from this technique... and because it starts with "Go". (Anyway, I've just found that another golden package exists, so it is possible that I need to change the name.) 

Combinatorial testing is a planned feature for Golden.

## Problems with snapshot testing

Non-deterministic output: this is not an exclusive problem of snapshot testing. Managing non-deterministic output is always a problem. In assertion testing you can introduce property based testing: instead of looking for exact values, you can look for desired properties of the output.

In snapshot testing things are a bit more complicated. It is difficult to check properties of a specific part of the output and ignore the value. Anyway, one solution is to look for specific patterns and do something about them: replace with a fixed but representative value, replace with some reminder... maybe it is possible to ignore that part of the output in order to compare with the snapshot.

Replacement of non-deterministic data is a planned feature for Golden.
