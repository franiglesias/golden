# Golden

A Go library for snapshot ðŸ“¸ testing.

[Reference](https://pkg.go.dev/github.com/franiglesias/golden)

## TL;DR

Snapshot testing is a technique in which the output of the subject under test is compared to an existing one (the snapshot) previously generated by running the very same subject under test. The basic idea is to ensure that changes made to the code doesn't affect to its behaviour.

This is useful to:

* test complex outputs such as objects, files or similar
* understand and put legacy code under test
* obtain high code coverage when starting to refactor legacy code or code that has no tests

**Current Status**: Verify, approval and golden master mode. Test name customization. Mostly stable API. 

**Pending features**: _Scrubbers_, that will let you manage not deterministic data.

**Usage advice**: Mostly ready for use, but use it at your own risk until it becomes stable, that will happen when v1.0.0 is released. Take into account that not all planned features are ready for prime time. API is pretty stable, but it could change as we are researching the best options.

### Installation

Standard Go module installation:

```shell
go get -u github.com/franiglesias/golden
```

### Basic Usage: Verify against an auto-generated snapshot

A snapshot test is pretty easy to write. Capture the output of the subject under test and pass it to `golden.Verify()`. `Golden` will take care of all.

```go
func TestSomething(t *testing.T) {
	output := SomeFunction("param1", "param2")
	
	golden.Verify(t, output)
}
```

#### How it works

The first time you run the test, a snapshot file will be generated at `__snapshots/TestSomething.snap` in the same package of the test. And the test **will pass**.

The file will contain the output generated by the subject under test, provided that it can be serialized as JSON. 

If the snapshot is ok for you, commit it with the code, so it can be used as comparison criteria in future runs. If not, delete the file, make the changes needed in the code or tests, and run again.


### Basic Usage: Approval mode

Approval mode is useful when you are writing new code. In this mode, the snapshot is generated and updated but the test never passes. Why? Because you will need to inspect the snapshot until you are happy with it, and you _approve_ it. 

Pass the option `golden.WaitApproval()` to run the test in approval mode.

```go
func TestSomething(t *testing.T) {
	output := SomeFunction("param1", "param2")
	
	golden.Verify(t, output, golden.WaitApproval())
}
```

Once you or a domain expert approves the snapshot, remove the `golden.WaitApproval()` option. That's all.


#### How it works

The first time you run the test, a snapshot file will be generated at `__snapshots/TestSomething.snap` in the same package of the test. And the test **will not pass**.

The file will contain the output generated by the subject under test, provided that it can be serialized as JSON.

If the snapshot is ok for you, remove the option `golden.WaitApproval()`, so it can be used as comparison criteria in future runs. If not, modify the code and run it again until the snapshot is fine.

You can use the same options as with `Verify`, like `UseSnapshot`.

#### Deprecated API

This API will be removed in the stable 1.0.0. version.

```go
func TestSomething(t *testing.T) {
	output := SomeFunction("param1", "param2")
	
	golden.ToApprove(t, output)
}
```

### Basic Usage: Golden Master mode

Golden Master mode is useful when you want to generate a lot of tests combining different values of the subject under test parameters. It will generate all possible combinations, creating a detailed snapshot with all the results.

You will need to create a wrapper function that exercises the subject under test managing both parameters and all return values, including errors. Basically, you will need to manage to return a `string` representation of the outcome of the SUT.

Here is an example testing a `Division` function.

```go
t.Run("should manage the error", func(t *testing.T) {
    setUp(t)
    f := func(args ...any) any {
        result, err := Division(args[0].(float64), args[1].(float64))
        if err != nil {
            return err.Error()
        }
        return result
    }

    dividend := []any{1.0, 2.0}
    divisor := []any{0.0, -1.0, 1.0, 2.0}

    gld.Master(t, f, golden.Combine(dividend, divisor))
})
```

#### How it works

The first time you run the test, a snapshot file will be generated at `__snapshots/should_manage_the_error.snap.json` in the same package of the test. This will be a JSON file with a description of the inputs and outputs of each generated test. The test itself will pass.

## What is Golden?

Golden is a library inspired by projects like [Approval Testing](https://approvaltests.com/). There are some other similar libraries out there, such as [Approval Tests](https://github.com/approvals/go-approval-tests), [Go-snaps](https://github.com/gkampitakis/go-snaps) or [Cupaloy](https://github.com/bradleyjkemp/cupaloy) that offer similar functionality.

So... Why to reinvent the wheel?

First of all, why not? I was willing to start a little side project to learn and practice some Golang things that I didn't find opportunity during the daily work. For example, creating a library for distribution, resolving some questions about managing state, creating friendly APIs, managing unknown types, etc. 

Second. I found some limitations in the libraries I was using (Approval tests, mainly) that make my work a bit uncomfortable. So, I started to look for alternatives. I wanted some more flexibility and customization. At the end of the day, I decided to create my own library.

## Snapshot testing

Snapshot testing is a testing technique that provides an alternative to assertion testing. In assertion testing, you compare the output of executing some unit of code with an expectation you have about it. For example, you could expect that the output would equal some value, or that it contains some text, etc.

Here you have a typical assertion for equality:

```go
assert.Equal(t, "Expected", output)
```

This works very well for TDD and for testing simple outputs. But it is tedious if you need to test complex objects, generated files and other big outputs. Also, it is not always the best tool for testing code that you don't know well or that was not created with testing in mind.

In snapshot testing, instead, you first obtain and persist the output of the current behavior of the subject under test. This is what we call a _snapshot_.

Then, you make some changes in the affected code, execute the unit again and, finally, you compare this last output with the one you persisted. As you can guess, in order to make the test pass, the code changes should not affect the behavior. This way, it is easy to understand that snapshot testing is great to put existing working code under test.

**Golden** automates the process of creating the snapshot the first time that the test runs using that snapshot as criteria in the following runs.

```go
golden.Verify(t, output)
```

In **Golden** we call this "Verification mode": the goal of the test is to verify that the output is the same as the snapshot.

But testing legacy or unknown code is not the only use case for snapshot testing.

In fact, snapshot testing is perfect for testing complex objects or outputs such as html, xml, json, generated code, etc. Provided that you can create a file with a serialized representation of the response, you can compare the snapshot with subsequent executions of the same unit of code. Suppose you need to generate an API response with lots of data. Instead of trying to figure out how to check every field value, you generate a snapshot with the data. After that, you will be using that snapshot to verify the execution. 

But this way of testing is weird for developing new features... How can I know that my generated output is correct so far?

## Approval testing

Approval testing is a variation of snapshot testing. Usually, in snapshot testing, the first time you execute the test, a new snapshot is created and the test automatically passes. Then, you make changes to the code and use the snapshot to ensure that there are not behavioral changes. This is the default behavior of `Golden`, as you can see.

In Approval Testing, the first test execution is not automatically passed. Instead, the snapshot is created, but you should review and approve it explicitly. This step allows you to be sure that the output is what you want or what was required. You can show it to the business people, to your client, to the user of your API or to whoever can review it. Once you get the approval of the snapshot and re-run the test, it will pass.

In fact, you could make changes and re-run the test all times you need until you are satisfied with the output and get the approval.

I think that Approval Testing was first introduced by [Llewellyn Falco](https://twitter.com/llewellynfalco). You can [learn more about this technique in their website](https://approvaltests.com/), where you can find how to approach development with it.

### How to do approval testing with **Golden**

Imagine you are writing some code that generates a complex struct, JSON object or another long and complex document. You need this object to be reviewed by a domain expert to ensure that it contains what is supposed to contain.

If you work in "verification mode" you will have to delete every snapshot that is created when running the test. Instead of that, you can use the "approval mode". It is very easy: you simply have to pass the `golden.WaitApproval()` function as option until the snapshot reflects exactly what you or the domain expert want.

```go
func TestSomething(t *testing.T) {
    output := SomeFunction("param1", "param2")

    golden.Verify(t, output, golden.WaitApproval())
}
```

This way, the test will always fail, and it will update the snapshot with the changes that happen in the output. This is because in "approval mode" you don't want to allow the test to pass.

So, how can I declare that a snapshot was approved? Easy: simple change the test to use the verification mode once you confirmed that the last snapshot was approved, by removing the `WaitApproval` option.

```go
func TestSomething(t *testing.T) {
    output := SomeFunction("param1", "param2")

    golden.Verify(t, output)
}
```

Other libraries requires you to use some sort external tool to rename or mark a snapshot as approved. Golden puts this distinction into the test itself. The fact that it fails, even after you've got the approval, allows you to remember that you will need to make something with the test. 

## Golden Master

There is another variation of snapshot testing. **Golden Master** is a technique introduced by Michael Feathers for working with legacy code that you don't understand. With this technique you could achieve high coverage really fast, so you can be sure that refactoring will be safe because you always will know if behaviour of the code is broken due to a change you introduced. The best thing is that you don't need to really understand the code in order to test it. Once you start refactoring things, it will be easier to introduce classic assertion testing and TDD and finally remove the Golden Master tests.

The technique requieres the creation of a big batch of tests for the same unit of code, by means of combinations of the parameters that you need to pass to such unit. The original Approval Tests package includes Combinations, a library that helps you to generate those combinatorial tests. 

There are several techniques to guess the best values you should use. You could, for example, study the code and look for significant values in conditionals with the help of a graphical coverage tool that shows you what parts of the code are executed or not depending on the values.

Once you complete the collection of possible values for each parameter, you will use the combination tools that will generate a batch of tests for you. The amount of tests is the product of multiplying the number of values per parameter. You can easily achieve tenths and even hundreds of tests for the same code unit.

As you have probably guessed, Golden takes its name from this technique... and because it starts with "Go". (Anyway, I've just found that there are lots of packages with the very same name).

### How to do Golden Master testing with **Golden**

Combinatorial test is a bit more tricky than plain snapshot. Not too much. The difficult part is how to use a simple API for the multiple possible Subjects Under Test (SUT).

Let's see an example. Imagine that you have this function that creates a border around a title for console output. In fact, we don't need to know anything about the implementation.

```go
func Border(title string, part string, span int) string {
	width := span*2 + len(title) + 2
	top := strings.Repeat(part, width)
	body := part + strings.Repeat(" ", span) + title + strings.Repeat(" ", span) + part
	return top + "\n" + body + "\n" + top + "\n"
}
```

The signature has three parameters, the first two are strings and the third is an integer. We want to test the function with different values for each parameter.

#### Wrap the subject under test

The first thing we need is a wrapper function that takes any number of parameters of `any` type and returns something. We are going to pass this function to the `Master` method. 


```go
f := func(args ...any) any {
	...
}
```

The body of the wrapper must convert the received parameters back to the types required by the SUT. How to do this is totally up to you. This example is pretty simple, and we only need to perform a type assertion. As you can see in the example, we receive the params as a slice of `any`, so you will identify the correspondent parameter by position.

The wrapper function will return `any` type. But if you find problems with doing so, try to convert the output to `string`.

```go
f := func(args ...any) any {
    title := args[0].(string)
    part := args[1].(string)
    span := args[2].(int)
	
    return Border(title, part, span)
}
```

**What can I do if the SUT returns an error?** The best thing is to return the error using the `Error()` method. It should appear in the snapshot as is, so you will know what input combination generated it. Let's see an example. Ths is the function we want to test:

```go
func Division(a float64, b float64) (float64, error) {
	if b == 0 {
		return 0, errors.New("division by 0")
	}

	return a / b, nil
}
```

And this is the wrapper function we've created for it:

```go
f := func(args ...any) any {
    result, err := Division(args[0].(float64), args[1].(float64))
    if err != nil {
        return err.Error()
    }
    return result
}
```

**What can I do if the SUT doesn't return an output?** A suggested technique for this it to add some kind of logging facility that you can retrieve and use that output for the test.

#### Prepare lists of values for each parameter

The next thing we need to do is to prepare lists of values for each parameter. You will populate a slice of `any`, with all the values that you want to test. The slice is typed as `any` to allow any kind of data, but remember to use types valid for the signature of the SUT.

```go
titles := []any{"Example 1", "Example long enough", "Another thing"}
parts := []any{"-", "=", "*", "#"}
times := []any{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

You will pass the collections of values with the convenience function `golden.Combine()`:

```go
golden.Combine(titles, parts, times)
```

This example will generate 132 tests (3 * 4 * 11).

**How can I choose the values?** It is an interesting question. In this example it doesn't matter the specific values because the code only has one execution flow. In many cases, you can find interesting values in conditionals, that control the execution flow, allowing you to obtain the most code coverage executing all possible branches. The precedent and following value of those are also interesting. If you are unsure, you can even use a batch with several random values. Remember that once you set up the test, adding or removing values is really easy.

#### Put it all together

And this is how you run a Golden Master test with Golden:

```go
t.Run("should create a golden master snapshot", func(t *testing.T) {
    f := func(args ...any) any {
        title := args[0].(string)
        part := args[1].(string)
        span := args[2].(int)
        return Border(title, part, span)
    }

    titles := []any{"Example 1", "Example long enough", "Another thing"}
    parts := []any{"-", "=", "*", "#"}
    times := []any{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

    golden.Master(t, f, golden.Combine(titles, parts, times))
})
```

`Master` method will invoke `Verify` under the hood, using the result of executing all the combinations to create the snapshot. This is a very special snapshot, by the way. First of all, it is a JSON file containing an array of JSON objects, each of them representing one example. Like this:


```json
[
  {
    "Id": 1,
    "Params": "Example 1, -, 0",
    "Output": "-----------\n-Example 1-\n-----------\n"
  },
  {
    "Id": 2,
    "Params": "Example long enough, -, 0",
    "Output": "---------------------\n-Example long enough-\n---------------------\n"
  },
  {
    "Id": 3,
    "Params": "Another thing, -, 0",
    "Output": "---------------\n-Another thing-\n---------------\n"
  },
  
]
```

I think this will help you to understand the snapshot, identify easily some cases and even post-process the result if you need to.

#### Another example, managing errors:

This is a test in which we manage error that can be returned by the SUT:

```go
t.Run("should manage the error", func(t *testing.T) {
    setUp(t)
    f := func(args ...any) any {
        result, err := Division(args[0].(float64), args[1].(float64))
        if err != nil {
            return err.Error()
        }
        return result
    }

    dividend := []any{1.0, 2.0}
    divisor := []any{0.0, -1.0, 1.0, 2.0}

    gld.Master(t, f, golden.Combine(dividend, divisor))
})
```

Take a look at first records of the snapshot. The error message appears as the output of the corresponding combination.

```json
[
  {
    "Id": 1,
    "Params": "1, 0",
    "Output": "division by 0"
  },
  {
    "Id": 2,
    "Params": "2, 0",
    "Output": "division by 0"
  },
  {
    "Id": 3,
    "Params": "1, -1",
    "Output": -1
  },
  {
    "Id": 4,
    "Params": "2, -1",
    "Output": -2
  },
  {
    "Id": 5,
    "Params": "1, 1",
    "Output": 1
  },
  {
    "Id": 6,
    "Params": "2, 1",
    "Output": 2
  },
  {
    "Id": 7,
    "Params": "1, 2",
    "Output": 0.5
  },
  {
    "Id": 8,
    "Params": "2, 2",
    "Output": 1
  }
]
```

## Customizing the behavior

### Customize the snapshot name

You can customize the snapshot name, by passing `golden.Snapshot()`:

```go
func TestSomething(t *testing.T) {
	output := SomeFunction("param1", "param2")
	
	golden.Verify(t, output, golden.Snapshot("my_snapshot"))
}
```

This will generate the snapshot in `__snapshots/my_snapshot.snap` in the same package of the test.

This is useful if you need:

* More than one snapshot in the same test
* Use an externally generated file as snapshot. For example, if you want your code to replicate the output of another system, provided that you have an example.


## How to deal with Not Deterministic output

This is not an exclusive problem of snapshot testing. Managing non-deterministic output is always a problem. In assertion testing you can introduce property based testing: instead of looking for exact values, you can look for desired properties of the output.

In snapshot testing things are a bit more complicated. It is difficult to check properties of a specific part of the output and ignore the value. Anyway, one solution is to look for specific patterns and do something about them: replace with a fixed but representative value, replace with some reminder... maybe it is possible to ignore that part of the output in order to compare with the snapshot.

> Replacement of non-deterministic data is a planned feature for Golden.

## How snapshots are named

By default, test names are used to auto generate the snapshot file name.

This test:

```go
func TestSomething (t *testing.T) {
	//...
}
```

Will generate the snapshot: `__snapshots/TestSomething.snap`

Inner tests with `t.Run` will work this way. The Test:

```go
func TestSomething (t *testing.T) {
	t.Run("should do something", func(t *testing.T) {
		//...
    })
}
```

Will generate the snapshot: `__snapshots/TestSomething/should_do_something.snap`

You can customize the snapshot file name by passing the option `golden.Snapshot("new_snapshot_name")`.
